<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MySQL的索引和SQL优化 | </title>
<link rel="shortcut icon" href="https://daffupman.github.io/favicon.ico?v=1604760406863">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://daffupman.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="MySQL的索引和SQL优化 |  - Atom Feed" href="https://daffupman.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="对于MySQL来说，可以使用sql语句查询出我们需要的数据，这是最基本的功能。在表中数据量比较小的情况下，SQL的性能差异并不明显，但是在表数据量比较大的时候，SQL执行的效率就有明显的时间差异。这里会记录我们如何发现SQL的性能问题，如何..." />
    <meta name="keywords" content="MySQL" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://daffupman.github.io">
  <img class="avatar" src="https://daffupman.github.io/images/avatar.png?v=1604760406863" alt="">
  </a>
  <h1 class="site-title">
    
  </h1>
  <p class="site-description">
    
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/daffupman" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              MySQL的索引和SQL优化
            </h2>
            <div class="post-info">
              <span>
                2020-11-07
              </span>
              <span>
                7 min read
              </span>
              
                <a href="https://daffupman.github.io/UPO6go_NY/" class="post-tag">
                  # MySQL
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://for-markdown.oss-cn-shanghai.aliyuncs.com/160e88b159fd464b9daa567059476e1b.jpg" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>对于MySQL来说，可以使用sql语句查询出我们需要的数据，这是最基本的功能。在表中数据量比较小的情况下，SQL的性能差异并不明显，但是在表数据量比较大的时候，SQL执行的效率就有明显的时间差异。这里会记录我们如何发现SQL的性能问题，如何优化SQL以及优化的底层原理。</p>
<h2 id="sql优化">SQL优化</h2>
<h3 id="如何找出效率低的sql">如何找出效率低的SQL</h3>
<p>要解决SQL效率低的问题就是如何发现哪些SQL导致了执行效率。常用的方法就是 <code>打开慢查询日志</code> ，方式如下：</p>
<pre><code class="language-mysql"># 开启/关闭慢查询日志，默认off
set global slow_query_log = ON/OFF
# 设置慢查询日志的输出位置
set global slow_query_log_file = log/slow_query.log
# 设置慢查询的时间阀值，默认10秒，需要重新打开会话可见。测试的时候一般设置成1秒
set global long_query_time = 1
# 开启/关闭 记录没有使用索引的sql
set global log_queries_not_using_indexes = ON/OFF
</code></pre>
<p>这样所有的慢查询sql都会记录到 <code>log/slow_query.log</code> 文件里了。我们可以直接阅读文件里的内容，来分析sql的执行问题。但是一般都是借助工具来分析，主要有两种工具：</p>
<ul>
<li>mysql的官方工具 <code>mysqldumpslow</code>，使用命令：<pre><code class="language-mysql">mysqldumpslow [OPTS...][LOGS...]
</code></pre>
</li>
<li>percona工具，这是第三方的，需要先下载(https://www.percona.com/downloads/percona-toolkit/3.2.1/binary/redhat/7/x86_64/percona-toolkit-3.2.1-1.el7.x86_64.rpm)：<pre><code class="language-bash">yum install -y perl-DBD-MySQL.x86_64 perl-DBI.x86 perl-Time-HiRes.x86_64 perl-IO-Socket-SSL.noarch perl-TermReadKey.x86_64 perl-Digest-MD5
 rpm -ivh percona-toolkit-3.2.1-1.el7.x86_64.rpm
</code></pre>
</li>
</ul>
<blockquote>
<p>数据库实时监控sql语句：</p>
<pre><code class="language-mysql">SELECT id, `user`, `host`, DB, command, `time`, state, info 
FROM information_schema.PROCESSLIST
WHERE TIME &gt;= 60;
</code></pre>
</blockquote>
<h3 id="分析执行计划">分析执行计划</h3>
<p>在获取到耗时较长的sql或我们刚写sql性能如何的时候，我们可以使用 <code>explain + SQL</code> 来输出sql的执行计划。<br>
<img src="https://for-markdown.oss-cn-shanghai.aliyuncs.com/20201022224740.png" alt="explain语法" loading="lazy"><br>
执行某条sql输出的执行计划示例：<br>
<img src="https://for-markdown.oss-cn-shanghai.aliyuncs.com/20201025213701.png" alt="示例执行计划" loading="lazy"><br>
可以看出执行计划有很多列，这里给出各个列的大致解释：</p>
<ul>
<li><code>id</code>：sql执行的顺序。id的值为一个数字或null。当id为一个数字的时候，表示查询执行的顺序；当id为null时，表示此行数据是由其他查询通过union出来的结果集。id值相同时，由上到下执行，id值不同，由大到小执行。</li>
<li><code>select_type</code>：查询类型，可选的值有：
<ul>
<li>SIMPLE：不包含子查询或是UNION操作的查询，多表JOIN也是SIMPLE；</li>
<li>PRIMARY：查询中如果包含任何子查询，那么最外层的查询则被标记为PRIMARY；</li>
<li>SUBQUERY：SELECT列表中的子查询；</li>
<li>DEPENDENT SUBQUERY：依赖外部结果的子查询；</li>
<li>UNION：union操作的第二个或是之后的查询的值为union；</li>
<li>DEPENDENT UNION：当union做为子查询时，第二个或第二个后的查询的select_type值；</li>
<li>UNION RESULT：UNION产生的结果集；</li>
<li>DERIVED：出现在FROM子句中的子查询。</li>
</ul>
</li>
<li><code>table</code>：指明从哪个表中获取数据。&lt;unionM,N&gt;由id为M和N查询union产生的结果集。&lt;derived N&gt;/&lt;subquery N&gt; 由id为n的查询产生的结果。</li>
<li><code>partitions</code>：对于分区表，显示查询的分区id；对于非分区表，显示NULL；</li>
<li><code>type</code>：索引使用的类型。<br>
<img src="https://for-markdown.oss-cn-shanghai.aliyuncs.com/20201025223733.png" alt="type列的值" loading="lazy"></li>
<li><code>possible_keys</code>：查询中可能会用到的索引；</li>
<li><code>key</code>：查询是实际用到的索引；</li>
<li><code>key_len</code>：实际使用索引的最大长度，由字段长度决定的；</li>
<li><code>ref</code>：表示哪些列或常量被用于索引查找；</li>
<li><code>rows</code>：根据统计信息预估的扫描的行数；</li>
<li><code>filtered</code>：表示返回结果的行数占需读取行数的百分比；</li>
<li><code>extra</code>：sql查询的一些额外的信息，可能显示的如下
<ul>
<li>distinct：优化distinct操作，在找到第一匹配的元组后即停止；</li>
<li>not exists：使用not exists来优化查询；</li>
<li>using filesort：使用文件来进行排序，通常会出现在order by或group by查询中；</li>
<li>using index：使用了覆盖索引进行查询；</li>
<li>using temporary：MySQL需要使用临时表来处理查询，常见于排序，子查询和分组查询；</li>
<li>using where：需要在MySQL服务器层使用where条件来过滤数据；</li>
<li>select tables optimized away：直接通过索引来获得数据，不用访问表。</li>
</ul>
</li>
</ul>
<h3 id="如何优化sql">如何优化sql</h3>
<p>可以从优化sql查询所涉及到的表中的索引或改写sql以达到更好的利用索引的目的。索引可以告诉存储引擎如何快速的查询到所需要的数据。InnoDB支持的索引类型有：</p>
<ul>
<li>Btree索引：平常使用中，如果没有说明索引的类型，一般都是Btree索引；
<ul>
<li>使用B+树的结构存储索引数据；</li>
<li>适用于全值匹配的查询
<blockquote>
<p>class_name = 'mysql' 或 class_name in ('mysql', 'postgreSQL')</p>
</blockquote>
</li>
<li>适合处理范围查找
<blockquote>
<p>study_cnt between 1000 and 3000 或 study_cnt &gt; 3000</p>
</blockquote>
</li>
<li>Btree索引的从索引的最左侧开始匹配查找列</li>
</ul>
</li>
<li>自适应Hash索引：为优化查询性能自动建立的，不需要开发人员或DBA手动管理；</li>
<li>全文索引：使用elasticsearch或solr</li>
<li>空间索引：地理位置的索引（不推荐）</li>
</ul>
<p>应该在什么列上建立索引？</p>
<ol>
<li>在where子句中的列，这些列是否有比较好的筛选性（列值的重复越小的，筛选性越好）</li>
<li>包含在ORDER BY、GROUP BY、DISTINCT中的字段</li>
<li>多表JOIN的关联列
<blockquote>
<p>创建索引：create index idx_xx ON table_name(column_name)<br>
查看索引：show index from table_name<br>
删除索引：alter table table_name drop index idx_xx</p>
</blockquote>
</li>
</ol>
<p>如何选择符合索引键的顺序？</p>
<ol>
<li>区分度最高的列放在联合索引的最左侧</li>
<li>使用最频繁的列放到联合索引的最左侧</li>
<li>尽量把字段长度小的列放在联合索引列的最左侧</li>
</ol>
<p>Btree索引的限制：</p>
<ul>
<li>只能从最左侧开始按索引键的顺序使用索引，不能跳过索引键</li>
<li>NOT IN和&lt;&gt;操作无法使用索引</li>
<li>索引列上不能使用表达式或者函数</li>
</ul>
<p>索引并非越多越好，索引可以提高查询效率，也会降低插入和更新的效率。使用IN查询是可以用到索引，但是IN查询列表很大，mysql引擎会认为使用全表扫描的效率更高而放弃使用索引。查询过滤的顺序也不必与索引键顺序相同才可以使用到索引，mysql引擎会自动调整顺序以适应索引顺序从而使用到索引。</p>
<h3 id="改写sql">改写SQL</h3>
<p>改写SQL的原则：</p>
<ul>
<li>使用outer join代替not in（MySQL8.0会自动转换）</li>
<li>使用CTE代替子查询</li>
<li>拆分复杂的大SQL为多个简单的小SQL</li>
<li>使用计算列优化查询<pre><code class="language-mysql"># 可以生成一个total_score计算列。为计算列添加索引，可优化查询速度。
 alter table imc_classvalue add column total_score DECIMAL(3,1) as (content_score + level_score + logic_score) 
</code></pre>
</li>
</ul>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#sql%E4%BC%98%E5%8C%96">SQL优化</a>
<ul>
<li><a href="#%E5%A6%82%E4%BD%95%E6%89%BE%E5%87%BA%E6%95%88%E7%8E%87%E4%BD%8E%E7%9A%84sql">如何找出效率低的SQL</a></li>
<li><a href="#%E5%88%86%E6%9E%90%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92">分析执行计划</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96sql">如何优化sql</a></li>
<li><a href="#%E6%94%B9%E5%86%99sql">改写SQL</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://daffupman.github.io/a5-Z-yWdo/">
              <h3 class="post-title">
                Shiro安全框架
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '9f58dbffcdaf89d24412',
    clientSecret: '1285bea2c70ba4c5d996b68cf847056d9b5b68fd',
    repo: 'daffupman.github.io',
    owner: 'daffupman',
    admin: ['daffupman'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  
  <a class="rss" href="https://daffupman.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
